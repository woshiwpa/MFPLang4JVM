<html>
<head>
<title>程式開發科學計算器幫助</title>
<meta http-equiv=Content-Type content="text/html; charset=UTF-8"></head>
<body style="background-color:white;">
<h2 style="color:blue">程式開發科學計算器幫助:並行計算函數</h2>
<table border="1" style="font-family:times;color:green;">
<tr>
<th>函數名</th>
<th>函數幫助信息</th>
</tr>
<tr>
<td><center>close_local</center></td>
<td><p>::mfp::paracomp::connect::close_local(2) :</p>
<p>close_local(local_info, is_server)關閉一個local對象。第一個參數，local_info，包含被關閉的local對象的信息。這些信息是generate_interface函數的返回值。第二個參數，is_server，是一個可選的布爾值參數。它決定是關閉一個服務端的local對象還是客戶端的local對象。它的缺省值是false。本函數的一個例子為close_local(a_generated_interface, false)。</p>
</td>
</tr>
<tr>
<td><center>close_out_connection</center></td>
<td><p>::mfp::paracomp::connect::close_out_connection(1...) :</p>
<p>close_out_connection關閉一個客戶端的連接對象。它有兩種工作模式。第一種工作模式有兩個參數。第一個參數，local_info，包含被關閉的連接對象所在客戶端的local對象的信息。這些信息是generate_interface函數的返回值。第二個參數，remote_info，包含被關閉的連接對象所在服務器端的local對象的信息。這些信息同樣也是generate_interface函數的返回值。第二種工作模式只有一個參數，就是客戶端通過調用connect函數得到的連接對象。本函數的一個例子為close_out_connection(a_generated_client_interface, a_generated_server_interface)。</p>
</td>
</tr>
<tr>
<td><center>connect</center></td>
<td><p>::mfp::paracomp::connect::connect(3) :</p>
<p>connect(local_info, remote_info, not_reuse_exist)初始化一個從由local_info定義的本地網絡界面對象到由remote_info定義的服務端網絡界面對象的連接。local_info和remote_info均由調用generate_interface函數獲得。第三個參數not_reuse_exist是一個布爾值。如果是True，意味著該函數重新建立一個新的連接，而不是使用已有的連接（如果存在已有連接的話）。該參數是可選參數，缺省值為False。如果成功本函數返回基於數組的字典，字典中的"CONNECT"關鍵字對應的是連接對象的定義，如果失敗本函數返回的字典中的"CONNECT"關鍵字對應的是NULL，同時還有一個"ERROR"關鍵字指向錯誤信息。</p>
</td>
</tr>
<tr>
<td><center>generate_interface</center></td>
<td><p>::mfp::paracomp::connect::generate_interface(2) :</p>
<p>generate_interface(protocol, address)返回一個本地interface對象的定義。它需要兩個參數。第一個參數是基於字符串的通信協議名，比如"TCPIP"；第二個參數是基於字符串的地址，比如"10.32.202.78"。第二個參數是可選參數，缺省值為本機的localhost地址，比如，對於"TCPIP"協議，本機localhost地址是"127.0.0.1"。</p>
</td>
</tr>
<tr>
<td><center>get_all_connect_call_ids</center></td>
<td><p>::mfp::paracomp::connect::get_all_connect_call_ids(1...) :</p>
<p>get_all_connect_call_ids返回服務器端一個用於監聽的地址所有的連接id或者一個連接的所有call沙盒id。它有兩種模式。第一種調用模式只有一個參數，為一個代表服務端本地信息的對象。 該對象為generate_interface函數的返回值。在這種模式下，本函數的返回值為所有從客戶端連入的連接的id數組。註意如果本地信息不合法，本函數將拋出異常。如果不是在服務端，將返回一個空數組。 第二種調用模式有兩個參數。第一個參數為一個代表服務端本地信息的對象。 該對象為generate_interface函數的返回值。第二個參數為一個服務端連接對象的id（該id可以通過調用get_call_info函數得到）。第二種模式下的返回值是該連接的所有call沙盒id的數組。註意如果本地信息不合法，本函數將拋出異常。如果不是在服務端或者連接id不存在，將返回NULL。本函數的一個例子是get_all_connect_call_ids(server_interface, connect_id)。</p>
</td>
</tr>
<tr>
<td><center>get_all_host_addresses</center></td>
<td><p>::mfp::paracomp::host::get_all_host_addresses(1) :</p>
<p>get_all_host_addresses(protocol_name)返回protocol_name協議在本機的所有界面的所有地址。參數protocol_name是可選的。如果沒有給出protocol_name參數或者給出是一個空的字符串，本函數返回本機所有被支持的通信協議在本機所有界面的所有地址。本函數的一個例子是get_all_host_addresses("TCPIP")。</p>
</td>
</tr>
<tr>
<td><center>get_call_info</center></td>
<td><p>::mfp::paracomp::connect::get_call_info(0) :</p>
<p>本函數如果不是在一個call沙盒中被調用，將會返回NULL。否則本函數返回一個數組。數組的第一個元素是調用本函數的call沙盒的id。數組的第二個元素是調用本函數的call沙盒所在的連接的id，數組的第三個元素是存有本地信息的對象。</p>
</td>
</tr>
<tr>
<td><center>get_local_host_address</center></td>
<td><p>::mfp::paracomp::host::get_local_host_address(1) :</p>
<p>get_local_host_address(protocol_name)返回protocol_name協議在本機的localhost地址。本函數的一個例子是get_local_host_address("TCPIP")。</p>
</td>
</tr>
<tr>
<td><center>initialize_local</center></td>
<td><p>::mfp::paracomp::connect::initialize_local(2) :</p>
<p>initialize_local(local_info, is_server)初始化一個本地interface對象。該對象由local_info定義（local_info是調用generate_interface的返回結果）。這個函數的第二個參數是一個布爾值，為true時初始化服務端interface對象，為false時初始化客戶端interface對象。這個參數可以省略，其缺省值是false。本函數如果成功返回true，否則返回false。</p>
</td>
</tr>
<tr>
<td><center>listen</center></td>
<td><p>::mfp::paracomp::connect::listen(1) :</p>
<p>listen(local_info)在一個本地interface對象上偵聽外部的連接請求。參數local_info是調用generate_interface函數的返回值。listen如果成功，返回true，否則返回false。</p>
</td>
</tr>
<tr>
<td><center>receive_sandbox_message</center></td>
<td><p>::mfp::paracomp::connect::receive_sandbox_message(1...) :</p>
<p>receive_sandbox_message函數返回沙盒或者MFP主進程發送的信息。發送者可能位於一個和本地有直接連接（這裏指的是通過MFP的connect函數構成的連接）的遠端MFP實例中（可能是一個call沙盒或者該MFP實例的主進程），也可能就是本地MFP實例的一個call沙盒或者該MFP實例的主進程。它有兩種工作模式。第一種工作模式只有一個參數，也就是等待的時間。如果是0，則意味著沒有等待，立即返回。如果隊列中有消息，則返回隊列中的第一個消息，否則，返回NULL。如果等待時間小於0，則意味著阻塞模式。也就是說如果隊列中沒有消息，函數將會阻塞。如果等待時間是正數，則代表等待的毫秒數。如果等待時間過去之後隊列中仍然沒有消息，則返回NULL。如果本函數是在沙盒中被調用，則必須采用第一種工作模式。第二種工作模式有兩個參數。第一個參數為一個代表本地信息（也就是監聽地址）的對象。它告訴本函數選擇哪一個本地地址收取消息。該信息對象可由調用generate_interface函數返回得到。第二個參數則是等待時間，其具體意義參見第一種工作模式。如果本函數是在MFP主進程中被調用，則必須采用第二種工作模式。本函數如果返回一個合法的消息，該返回值則是一個基於數組的字典。其中，“InterfaceInfo”的字段是發送端的本地信息，包括協議和地址。如果發送端和接收端位於同一個MFP實例中，發送端並非通過loopback連接來發送消息給接收端，並且接收端是該MFP實例的一個call沙盒而發送端是該MFP實例的主進程，這個字段則為NULL。“ConnectId”的字段是發送端的連接ID，如果發送端是MFP實例的主進程，該字段為一個空字符串。“CallId”的字段是發送端的call沙盒ID，如果發送端是MFP實例的主進程，該字段為0。“Message”的字段是消息的內容。本函數的兩個例子為receive_sandbox_message(-1)和receive_sandbox_message(local_info, -1)。</p>
</td>
</tr>
<tr>
<td><center>send_sandbox_message</center></td>
<td><p>::mfp::paracomp::connect::send_sandbox_message(1...) :</p>
<p>send_sandbox_message函數將消息發送到沙盒或MFP主進程。它具有四種工作模式。第一種工作模式是從沙盒向其本地MFP主進程發送消息。在這種情況下，該功能只有一個參數，即消息內容。請註意，消息內容不必是字符串。例如，send_sandbox_message([1,2,3])從沙盒向本地MFP主進程發送[1,2,3]。第二種工作模式是將消息從MFP主進程或沙盒發送到本地沙盒。在這種情況下，該功能需要四個參數。第一個參數是本地信息對象。可以從generate_interface函數獲得此本地信息對象。啟動接收方沙盒的call請求被本地信息對象所代表的接口地址接受。第二個參數是接收方沙盒的連接ID，如果接口基於TCPIP協議，則為接收方本地接口的地址。第三個參數是接收方沙盒的call沙盒Id。最後一個參數是消息內容。此模式的一個示例是send_sandbox_message(local_info,"127.0.0.1",1,238.975+3.01i)。第三種工作模式是將消息從本地沙盒或MFP主進程發送到遠端MFP主進程。請註意，本地MFP實例必須已經通過調用connect函數連接到遠端MFP實例。此模式需要兩個參數。第一個是從connect函數返回的連接對象（即返回值的“CONNECT”字段）。第二個參數是消息內容。一個示例是send_sandbox_message(conn1,"Hello!")。最後一種工作模式是將消息從本地沙盒或MFP主進程發送到遠端沙盒。請註意，本地MFP實例必須通過調用connect函數連接到遠端MFP實例。此模式需要五個參數。第一個參數是從連接函數返回的連接對象（即返回值的“CONNECT”字段）。第二個參數是從generate_interface函數獲得的遠程接口對象。此遠程接口位於連接的另一端。遠程接口接受了啟動接收方沙盒的call請求。第三個參數是接收方沙盒的連接ID，如果接口基於TCPIP協議，則為遠端接口的地址。第四個參數是接收方沙盒的call沙盒ID。最後一個參數是消息內容。此模式的一個示例是send_sandbox_message(conn1,remote_info,"192.168.1.139",4,[[1,2],[3,4]])。</p>
</td>
</tr>
<tr>
<td><center>suspend_until_cond</center></td>
<td><p>::mfp::paracomp::threading::suspend_until_cond(4) :</p>
<p>此函數將掛起當前線程，直到滿足特定條件為止。它有四個參數。第一個參數為變量名稱。請註意，變量名不是字符串。第二個參數是布爾值。如果為TRUE，則該函數僅在寫入變量的值（不必更改）之後才開始檢查條件是否滿足。否則，函數將在調用函數時立即檢查是否滿足條件。此參數是可選的。默認情況下為TRUE。第三個參數是運算符字符串。當前此參數僅支持以下值，即""，"=="，"!="，">"，"<"，">="和"<="。""表示如果變量值被寫入（未必是被更改），則滿足條件。其他運算符意味著使用運算符比較變量的值。如果比較返回TRUE，則滿足條件。此參數也是可選的。默認情況下為""。最後一個參數是要比較的值。這也是一個可選參數。如果運算符為""，此參數沒有任何作用。對於其他運算符，默認情況下，此參數的值為變量的當前值。例如，suspend_until_cond(a)等於調用suspend_until_cond(a,TRUE,"")，這意味著掛起當前線程，直到變量a被另一個線程寫入。另一個示例是suspend_until_cond(a,FALSE,"!=")，這意味著掛起當前線程，直到變量a的值更改為止。第三個示例是suspend_until_cond(a,TRUE,">=",37)，這意味著掛起當前線程，直到寫入變量a（不一定更改a的值），並且寫入後的值不小於37。如果寫入後的值無法和37進行比較，例如a新的值為"Hello"，則當前線程仍然被阻塞。</p>
</td>
</tr>
</table>
</body>
</html>
