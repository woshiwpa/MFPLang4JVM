<html>
<head>
<title>程式開發科學計算器幫助</title>
<meta http-equiv=Content-Type content="text/html; charset=UTF-8"></head>
<body style="background-color:white;">
<h2 style="color:blue">程式開發科學計算器幫助：內置函數</h2>
<table border="1" style="font-family:times;color:green;">
<tr>
<th>函數名</th>
<th>函數幫助資訊</th>
</tr>
<tr>
<td><center>abs</center></td>
<td><p>abs(1) :</p>
<p>abs(x)返回復數x的模或者實數x的絕對值。</p>
</td>
</tr>
<tr>
<td><center>acos</center></td>
<td><p>acos(1) :</p>
<p>acos(x)返回x的反余弦值，註意x可以為復數。</p>
</td>
</tr>
<tr>
<td><center>alloc_array</center></td>
<td><p>alloc_array(1...) :</p>
<p>alloc_array(x...)返回一個新分配的矩陣，其大小由參數決定。所有的參數都必須為正整數。</p>
<p>alloc_array(2) :</p>
<p>alloc_array(x, y)返回一個新分配的矩陣，其大小由參數x決定，參數x或者是一批正整數，或者是一個正整數數列。參數y是矩陣中所有元素的初始值，註意y參數可省略，如果省略，所有元素被初始化為0。</p>
</td>
</tr>
<tr>
<td><center>and</center></td>
<td><p>and(1...) :</p>
<p>and(x...)接受不少於1個的任意個數的參數，返回這些參數的邏輯與值。如果某一個參數不是布爾類型，將會被自動轉換為布爾類型。</p>
</td>
</tr>
<tr>
<td><center>angle</center></td>
<td><p>angle(1) :</p>
<p>angle(x)返回覆數x基於弧度的幅角值。</p>
</td>
</tr>
<tr>
<td><center>asin</center></td>
<td><p>asin(1) :</p>
<p>asin(x)返回x的反正弦值，註意x可以為復數。</p>
</td>
</tr>
<tr>
<td><center>atan</center></td>
<td><p>atan(1) :</p>
<p>atan(x)返回x的反正切值，註意x可以為復數。</p>
</td>
</tr>
<tr>
<td><center>cd</center></td>
<td><p>cd(1) :</p>
<p>change_dir(path)（別名cd(path)）將當前路徑變為字串路徑path。如果成功，返回true，否則返回false。例子包括change_dir("D:\\Windows") (Windows)和cd("/") (Android)。</p>
</td>
</tr>
<tr>
<td><center>ceil</center></td>
<td><p>ceil(1) :</p>
<p>ceil(x), x是浮點數，返回不小於x的最小整數。</p>
<p>ceil(2) :</p>
<p>ceil(x,y)，x是浮點數，y是非負整數，返回不小於x的小數點後面保留y位有效數字的最小數值。</p>
</td>
</tr>
<tr>
<td><center>change_dir</center></td>
<td><p>change_dir(1) :</p>
<p>change_dir(path)（別名cd(path)）將當前路徑變為字串路徑path。如果成功，返回true，否則返回false。例子包括change_dir("D:\\Windows") (Windows)和cd("/") (Android)。</p>
</td>
</tr>
<tr>
<td><center>clone</center></td>
<td><p>clone(1) :</p>
<p>clone(source_value)復制輸入參數source_value並返回source_value的拷貝。輸入參數可以是任何數據類型，包括字串，數，復數以及陣列。比如，如果變量a等於[1,2]，用戶執行語句variable b = clone(a)就會得的b等於[1,2]。但是這時候b和a是兩個不同的數據。如果用戶改變a的值，比如，設置a[0]等於3，a將會變成[3,2]但是b依然是[1，2]。</p>
</td>
</tr>
<tr>
<td><center>conv_bin_to_dec</center></td>
<td><p>conv_bin_to_dec(1) :</p>
<p>conv_bin_to_dec(x)將一個二進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個十進制的數值。</p>
</td>
</tr>
<tr>
<td><center>conv_bin_to_hex</center></td>
<td><p>conv_bin_to_hex(1) :</p>
<p>conv_bin_to_hex(x)將一個二進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個代表16進制數的字串。</p>
</td>
</tr>
<tr>
<td><center>conv_bin_to_oct</center></td>
<td><p>conv_bin_to_oct(1) :</p>
<p>conv_bin_to_oct(x)將一個二進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個代表八進制數的字串。</p>
</td>
</tr>
<tr>
<td><center>conv_dec_to_bin</center></td>
<td><p>conv_dec_to_bin(1) :</p>
<p>conv_dec_to_bin(x)將一個十進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個代表二進制數的字串。</p>
</td>
</tr>
<tr>
<td><center>conv_dec_to_hex</center></td>
<td><p>conv_dec_to_hex(1) :</p>
<p>conv_dec_to_hex(x)將一個十進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個代表16進制數的字串。</p>
</td>
</tr>
<tr>
<td><center>conv_dec_to_oct</center></td>
<td><p>conv_dec_to_oct(1) :</p>
<p>conv_dec_to_oct(x)將一個十進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個代表八進制數的字串。</p>
</td>
</tr>
<tr>
<td><center>conv_hex_to_bin</center></td>
<td><p>conv_hex_to_bin(1) :</p>
<p>conv_hex_to_bin(x)將一個16進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個代表二進制數的字串。</p>
</td>
</tr>
<tr>
<td><center>conv_hex_to_dec</center></td>
<td><p>conv_hex_to_dec(1) :</p>
<p>conv_hex_to_dec(x)將一個16進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個十進制的數值。</p>
</td>
</tr>
<tr>
<td><center>conv_hex_to_oct</center></td>
<td><p>conv_hex_to_oct(1) :</p>
<p>conv_hex_to_oct(x)將一個16進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個代表八進制數的字串。</p>
</td>
</tr>
<tr>
<td><center>conv_ints_to_str</center></td>
<td><p>conv_ints_to_str(1) :</p>
<p>conv_ints_to_str(int_or_array)將一個整數或者一組整數轉換成一個Unicode字串。如果只有一個整數，返回的字串只包含一個Unicode字符，否則，返回字串的字符數目和int_or_array中的元素數目一致。如果需要轉換的整數是負數或者超出了Unicode字符集的定義範圍，則被轉換成整數0所對應的Unicode字符。示例包括conv_ints_to_str([20320, 22909, 25105, 22909, 22823, 23478, 22909])返回"你好我好大家好"，以及conv_ints_to_str(20320)返回"你"。</p>
</td>
</tr>
<tr>
<td><center>conv_oct_to_bin</center></td>
<td><p>conv_oct_to_bin(1) :</p>
<p>conv_oct_to_bin(x)將一個八進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個代表二進制數的字串。</p>
</td>
</tr>
<tr>
<td><center>conv_oct_to_dec</center></td>
<td><p>conv_oct_to_dec(1) :</p>
<p>conv_oct_to_dec(x)將一個八進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個十進制的數值。</p>
</td>
</tr>
<tr>
<td><center>conv_oct_to_hex</center></td>
<td><p>conv_oct_to_hex(1) :</p>
<p>conv_oct_to_hex(x)將一個八進制的非負數或代表該數的字串x（x可以為浮點數，也可以為整數）轉換為一個代表16進制數的字串。</p>
</td>
</tr>
<tr>
<td><center>conv_str_to_ints</center></td>
<td><p>conv_str_to_ints(1) :</p>
<p>conv_str_to_ints(str)將一個Unicode字串轉換成一個整數數組。通常，一個Unicode字符對應一個整數（但也有可能對應兩個整數，如果該Unicode字符超出了UTF-16字符集的範圍。但這種情況很少出現）。如果字串是空的，則返回一個空數組。一個示例為conv_str_to_ints("你好我好大家好")返回[20320, 22909, 25105, 22909, 22823, 23478, 22909]。</p>
</td>
</tr>
<tr>
<td><center>copy_file</center></td>
<td><p>copy_file(3) :</p>
<p>copy_file(source, destination, replace_exist)函數程式拷貝位於字串source路徑的檔案或檔案目錄到位於字串destination路徑的檔案或檔案目錄。如果第三個參數，replace_exist，是true，那麼如果目標檔案已經存在，它將會被源檔案（或者源檔案目錄中的對應檔案）替換。註意第三個參數可以省略，它的缺省值為false。例子包括copy_file("c:\\temp\\try1", "D:\\", true) (Windows)和copy_file("/mnt/sdcard/testfile.txt", "./testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>cos</center></td>
<td><p>cos(1) :</p>
<p>cos(x)返回x的余弦值，註意x可以為復數。</p>
</td>
</tr>
<tr>
<td><center>create_file</center></td>
<td><p>create_file(2) :</p>
<p>create_file(path, is_folder)創建一個檔案（如果is_folder是false或者不存在）或者檔案 目錄（如果if_folder是true）。如果這個基於字串的路徑path的上級目錄不存在，不存在的上級目錄將會被創建。如果檔案能夠被創建，這個函數程式返回true，否則返回false。例子包括create_file("c:\\temp\\try1", true) (Windows)和create_file("testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>delete_file</center></td>
<td><p>delete_file(2) :</p>
<p>delete_file(path, delete_children_in_folder)刪除一個位於字串path的檔案或者檔案目錄。如果是一個目錄且第二個參數delete_children_in_folder是true，目錄中的所以檔案和子目錄將會被刪除。註意第二個參數可以省略，它的缺省值是false。如果刪除成功，本函數程式返回true，否則返回false。例子包括delete_file("c:\\temp\\try1", true) (Windows)和delete_file("testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>det</center></td>
<td><p>det(1) :</p>
<p>det(x)計算2維方陣x的行列式值。</p>
</td>
</tr>
<tr>
<td><center>deter</center></td>
<td><p>deter(1) :</p>
<p>deter(x)計算2維方陣x的行列式值。</p>
</td>
</tr>
<tr>
<td><center>dir</center></td>
<td><p>dir(1) :</p>
<p>print_file_list(path) (别名ls(path)或者dir(path))函數程式和Windows平臺上的dir命令以及Linux平臺上的ls命令類似。它打印出位於字串path路徑的档案或者目錄中的所有子档案和子目錄的信息。它返回打印的條目的個數。如果不存在一個檔案或者目錄對應於path路徑，它返回-1。註意參數path是可以省略的。它的缺省值是當前目錄。例子包括dir("c:\\temp\\try1") (Windows)和ls("../testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>eig</center></td>
<td><p>eig(1) :</p>
<p>eig(A)計算2維方陣A的特征向量和特征值。這個函數程式返回一個包含兩個成員的列表。第一個成員是特征向量陣列，每一列是一個特征向量。第二個成員是一個對角陣列，每一個對角線元素是一個特征值。註意運算這個程式非常耗費內存和CPU資源，如果在移動設備上運行，征列A的尺寸最好不要超過6*6，如果在電腦上運行，最好不要超過8*8，否則可能造成內存不足而程序崩潰或者運行很長時間而沒有結果。</p>
<p>eig(2) :</p>
<p>eig(A, B)計算2維方陣A相對於同樣尺寸的方陣B的特征向量和特征值，也就是Av = lambda * Bv，在這裏，。lambda是一個特征值，v是一個特征向量。第二個參數，B，可以省略，其缺省值為I陣列。這個函數程式返回一個包含兩個成員的列表。第一個成員是特征向量陣列，每一列是一個特征向量。第二個成員是一個對角陣列，每一個對角線元素是一個特征值。註意運算這個程式非常耗費內存和CPU資源，如果在移動設備上運行，征列A的尺寸最好不要超過6*6，如果在電腦上運行，最好不要超過8*8，否則可能造成內存不足而程序崩潰或者運行很長時間而沒有結果。</p>
</td>
</tr>
<tr>
<td><center>evaluate</center></td>
<td><p>evaluate(1...) :</p>
<p>evaluate(expr_string,var_string1,var_value1,var_string2,var_value2, ...) 返回當基於字串的變數var_string1等於var_value1，var_string2等於var_value2，...時，基於字串的表達式expr_string的值。註意變數var_string1，var_string2，...的值可以為任意類型。變數的數目可以為0，也就是說，evaluate("3+2")是合法的。</p>
</td>
</tr>
<tr>
<td><center>exp</center></td>
<td><p>exp(1) :</p>
<p>exp(x)返回自然對數e的x次方，x可以為實數或者虛數。</p>
</td>
</tr>
<tr>
<td><center>eye</center></td>
<td><p>eye(1) :</p>
<p>eye(x)返回正整數x乘x的2維方陣I。註意表達式eye(0)返回常數1。</p>
<p>eye(2) :</p>
<p>eye(x,y)返回y（y為正整數）維方陣I，註意每一維長度均為正整數x。</p>
</td>
</tr>
<tr>
<td><center>fclose</center></td>
<td><p>fclose(1) :</p>
<p>fclose(fd)關閉文件號fd所對應的檔案。如果檔案號不存在，返回-1，否則返回0。</p>
</td>
</tr>
<tr>
<td><center>feof</center></td>
<td><p>feof(1) :</p>
<p>feof(fd)用于确定是否已经到达档案号为fd的读模式档案的末尾。如果是，返回true，否则返回false。如果档案号不合法，抛出异常。</p>
</td>
</tr>
<tr>
<td><center>floor</center></td>
<td><p>floor(1) :</p>
<p>floor(x)，x是浮點數，返回不大於x的最大整數。</p>
<p>floor(2) :</p>
<p>floor(x,y)，x是浮點數，y是非負整數，返回不大於x的小數點後面保留y位有效數字的最大數值。</p>
</td>
</tr>
<tr>
<td><center>fopen</center></td>
<td><p>fopen(2) :</p>
<p>fopen(path, mode)打开位于path路径的档案并返回档案号以进行后续读写操作。它和C以及Matlab中的同名函数程式用法相似。但它仅支持"r"、"a"、"w"、"rb"、"ab"和"wb"六种读写模式。例子包括fopen("C:\\Temp\\Hello.dat", "ab") (Windows)和fopen("./hello.txt", "r") (Android)。</p>
<p>fopen(3) :</p>
<p>fopen(path, mode, encoding)用字符編碼encoding打開位於path路徑的檔案並返回檔案號以進行後續讀寫操作。由於只有文本檔案支持字符編碼，參數mode只能為"r"、"a"和"w"3種讀寫模式。例子包括fopen("C:\\Temp\\Hello.txt", "a", "LATIN-1") (Windows)和fopen("./hello.txt", "r", "UTF-8") (Android)。</p>
</td>
</tr>
<tr>
<td><center>fprintf</center></td>
<td><p>fprintf(2...) :</p>
<p>printf(format_string, ...)，sprintf(format_string, ...)和fprintf(fd, format_string, ...)和C/C++中的对应函数程式工作方式相似。这些函数程式通过format_string和其后的数值参数构造出一个新的字串，printf将字串打印到标准输出，sprintf将字串作为返回值返回，fprintf则将字串输出到档案号为fd的文本档案。字串format_string支持输入整数（%d、%i、%x等），浮点数（%e、%f等），字符和字串（%c和%s）等等。用户可以在C语言的帮助手册中找到format_string的构造方法。例如，printf("Hello world!%f", 3.14)将会打印输出"Hello world!3.140000"，而sprintf("%c%d", "A", 9)则返回"A9"（注意MFP不支持单一字符数据类型，所以单一的字符将会存储为一个只包括一个字符的字串）。</p>
</td>
</tr>
<tr>
<td><center>fread</center></td>
<td><p>fread(4) :</p>
<p>fread(fd, buffer, from, length)從檔案（檔案號fd）中讀取length個字節數據，並把讀出的數據保存在數組buffer中（從buffer的索引from開始保存）。註意from和length必須非負，並且from+length必須不比buffer的容量大。參數from和length可以同時省略。如果它們被省略，意味著fread讀取整個buffer容量的字節數據並保存在整個buffer中。Buffer也可以省略，如果buffer省略，fread讀取一個字節並返回。如果fread在讀取之前發現已經到達檔案末尾，則返回-1，否則返回讀取字節的個數（如果buffer不省略）。如果檔案不存在或非法或不可以訪問，將會拋出異常。例子包括fread(1)、fread(2, byte_buffer)以及fread(2, byte_buffer, 3, 7)。</p>
</td>
</tr>
<tr>
<td><center>freadline</center></td>
<td><p>freadline(1) :</p>
<p>freadline(fd)讀取文本檔案（檔案號是fd）的一行。如果freadline在讀取之前發現已經到達檔案末尾，它返回NULL。否則，它返回基於字串的這一行的內容，但不包括結尾的換行符。</p>
</td>
</tr>
<tr>
<td><center>fscanf</center></td>
<td><p>fscanf(2) :</p>
<p>scanf(format_string)，sscanf(input_from, format_string)和fscanf(fd, format_string)和C/C++中的對應函數程式工作方式相似。scanf讀取用戶的一行輸入，sscanf讀取字串input_from，fscanf從檔案（檔案號fd）中讀取檔案內容。字串format_string支持輸入整數（%d、%i、%x等），浮點數（%e、%f等），字符和字串（%c和%s）等等。用戶可以在C語言的幫助文檔中找到format_string的構造方法。但是，和C語言有所不同，MFP中的這些函數程式不需要輸入用於存儲讀取數值的參數。所有的讀取的數值將會保存在一個數組中作為返回值返回。比如，sscanf("3Hello world!", "%d%c%c%s")將會返回[3, "H", "e", "llo"]（註意MFP不支持單一字符數據類型，所以單一的字符將會存儲為一個只包括一個字符的字串）。</p>
</td>
</tr>
<tr>
<td><center>fwrite</center></td>
<td><p>fwrite(4) :</p>
<p>fwrite(fd, buffer, from, length)向檔案（檔案號fd）中寫入length個字節數據。這些字節數據保存在數組buffer中（從buffer的索引from開始）。註意from和length必須非負，並且from+length必須不比buffer的容量大。參數from和length可以同時省略。如果它們被省略，意味著fwrite寫入整個buffer的字節數據。Buffer也可以是一個單獨的字節，在這種情況下fwrite僅寫入一個字節的數據。如果檔案不存在或非法或不可以訪問，將會拋出異常。例子包括fwrite(1, 108)、fwrite(2, byte_buffer)以及fwrite(2, byte_buffer, 3, 7)。</p>
</td>
</tr>
<tr>
<td><center>get_absolute_path</center></td>
<td><p>get_absolute_path(1) :</p>
<p>get_absolute_path(fd_or_path)返回檔案號fd_or_path（這裏fd_or_path是一個整數）或者相對路徑為fd_or_path（這裏fd_or_path是一個字串）所對應的檔案的絕對路徑字串。</p>
</td>
</tr>
<tr>
<td><center>get_canonical_path</center></td>
<td><p>get_canonical_path(1) :</p>
<p>get_canonical_path(fd_or_path)返回檔案號fd_or_path（這裏fd_or_path是一個整數）或者相對路徑為fd_or_path（這裏fd_or_path是一個字串）所對應的檔案的標準路徑（不依賴符號鏈接的絕對路徑）字串。</p>
</td>
</tr>
<tr>
<td><center>get_day_of_month</center></td>
<td><p>get_day_of_month(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分別返回時標timestamp所對應的年，月，本年中的第幾天，本月中的第幾天，本星期中的第幾天（禮拜天是第0天，禮拜一是第一天，...），小時，分鐘，秒鐘和毫秒。時標是時標所表示的時刻和1970年1月1日午夜（UTC）的毫秒數時間差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是禮拜天。</p>
</td>
</tr>
<tr>
<td><center>get_day_of_week</center></td>
<td><p>get_day_of_week(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分別返回時標timestamp所對應的年，月，本年中的第幾天，本月中的第幾天，本星期中的第幾天（禮拜天是第0天，禮拜一是第一天，...），小時，分鐘，秒鐘和毫秒。時標是時標所表示的時刻和1970年1月1日午夜（UTC）的毫秒數時間差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是禮拜天。</p>
</td>
</tr>
<tr>
<td><center>get_day_of_year</center></td>
<td><p>get_day_of_year(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分別返回時標timestamp所對應的年，月，本年中的第幾天，本月中的第幾天，本星期中的第幾天（禮拜天是第0天，禮拜一是第一天，...），小時，分鐘，秒鐘和毫秒。時標是時標所表示的時刻和1970年1月1日午夜（UTC）的毫秒數時間差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是禮拜天。</p>
</td>
</tr>
<tr>
<td><center>get_eigen_values</center></td>
<td><p>get_eigen_values(1) :</p>
<p>get_eigen_values(A)計算2維方陣A的特征值。這個函數程式返回所有特征值，包括重復的特征值的列表。註意運算這個程式非常耗費內存和CPU資源，如果在移動設備上運行，征列A的尺寸最好不要超過6*6，如果在電腦上運行，最好不要超過8*8，否則可能造成內存不足而程序崩潰或者運行很長時間而沒有結果。</p>
<p>get_eigen_values(2) :</p>
<p>get_eigen_values(A, B)計算2維方陣A相對於同樣尺寸的方陣B的特征值，也就是Av = lambda * Bv，在這裏，。lambda是一個特征值，v是一個特征向量。第二個參數，B，可以省略，其缺省值為I陣列。這個函數程式返回所有特征值，包括重復的特征值的列表。註意運算這個程式非常耗費內存和CPU資源，如果在移動設備上運行，征列A的尺寸最好不要超過6*6，如果在電腦上運行，最好不要超過8*8，否則可能造成內存不足而程序崩潰或者運行很長時間而沒有結果。</p>
</td>
</tr>
<tr>
<td><center>get_file_last_modified_time</center></td>
<td><p>get_file_last_modified_time(1) :</p>
<p>get_file_last_modified_time(path)返回基於字串路徑的path的檔案或目錄的上一次更改時間。該時間等於從1970年1月1日午夜開始到上一次更改時刻所經歷的毫秒數。如果path不存在或者沒有訪問權限，返回-1。</p>
</td>
</tr>
<tr>
<td><center>get_file_path</center></td>
<td><p>get_file_path(1) :</p>
<p>get_file_path(fd)返回文件號fd（fd是一個整數）所對應的文件的路徑字串。</p>
</td>
</tr>
<tr>
<td><center>get_file_separator</center></td>
<td><p>get_file_separator(0) :</p>
<p>get_file_separator()返回路徑分割符。在Windows平臺下返回字串"\\"，在Linux和Android平臺下返回字串"/"。</p>
</td>
</tr>
<tr>
<td><center>get_file_size</center></td>
<td><p>get_file_size(1) :</p>
<p>get_file_size(path)返回基于字串路径的path的档案大小。如果path不是对应一个档案或者没有权限或者不存在，返回-1。</p>
</td>
</tr>
<tr>
<td><center>get_hour</center></td>
<td><p>get_hour(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分別返回時標timestamp所對應的年，月，本年中的第幾天，本月中的第幾天，本星期中的第幾天（禮拜天是第0天，禮拜一是第一天，...），小時，分鐘，秒鐘和毫秒。時標是時標所表示的時刻和1970年1月1日午夜（UTC）的毫秒數時間差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是禮拜天。</p>
</td>
</tr>
<tr>
<td><center>get_millisecond</center></td>
<td><p>get_millisecond(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分別返回時標timestamp所對應的年，月，本年中的第幾天，本月中的第幾天，本星期中的第幾天（禮拜天是第0天，禮拜一是第一天，...），小時，分鐘，秒鐘和毫秒。時標是時標所表示的時刻和1970年1月1日午夜（UTC）的毫秒數時間差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是禮拜天。</p>
</td>
</tr>
<tr>
<td><center>get_minute</center></td>
<td><p>get_minute(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分別返回時標timestamp所對應的年，月，本年中的第幾天，本月中的第幾天，本星期中的第幾天（禮拜天是第0天，禮拜一是第一天，...），小時，分鐘，秒鐘和毫秒。時標是時標所表示的時刻和1970年1月1日午夜（UTC）的毫秒數時間差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是禮拜天。</p>
</td>
</tr>
<tr>
<td><center>get_month</center></td>
<td><p>get_month(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分別返回時標timestamp所對應的年，月，本年中的第幾天，本月中的第幾天，本星期中的第幾天（禮拜天是第0天，禮拜一是第一天，...），小時，分鐘，秒鐘和毫秒。時標是時標所表示的時刻和1970年1月1日午夜（UTC）的毫秒數時間差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是禮拜天。</p>
</td>
</tr>
<tr>
<td><center>get_num_of_results_sets</center></td>
<td><p>get_num_of_results_sets(1) :</p>
<p>get_num_of_results_sets(x)返回solve返回值x中所包含的解集的組數。</p>
</td>
</tr>
<tr>
<td><center>get_second</center></td>
<td><p>get_second(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分別返回時標timestamp所對應的年，月，本年中的第幾天，本月中的第幾天，本星期中的第幾天（禮拜天是第0天，禮拜一是第一天，...），小時，分鐘，秒鐘和毫秒。時標是時標所表示的時刻和1970年1月1日午夜（UTC）的毫秒數時間差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是禮拜天。</p>
</td>
</tr>
<tr>
<td><center>get_solved_results_set</center></td>
<td><p>get_solved_results_set(2) :</p>
<p>get_solved_results_set(x, y)返回solve程式塊返回值x中所包含的第y+1組解集。註意本函數程式返回一個一維陣列，陣列中的第一個元素是solve程式塊的第一個待解變數的值，第二個元素是solve程式塊的第二個待解變數的值，依次類推。</p>
</td>
</tr>
<tr>
<td><center>get_time_stamp</center></td>
<td><p>get_time_stamp(1...) :</p>
<p>get_time_stamp(string_or_year, ...)返回由其參數所決定的時標。時標是時標所表示的時刻和1970年1月1日午夜（UTC）的毫秒數時間差。這個函數程式有兩種工作模式。第一種模式是get_time_stamp(string_time_stamp)。這種模式僅僅接受一個字串參數，該參數必須基於yyyy-mm-dd hh:mm:ss[.f...]的格式。其中，秒的分數部分可以忽略。第二種模式是get_time_stamp(year, month, day, hour, minute, second, millisecond)。這些參數中，除了第一個參數year（年），所有的其他參數都可以省略。如果省略，month（月）和day（日）的缺省值是1，hour（小時），minute（分鐘），second（秒）和millisecond（毫秒）的缺省值是0。比如get_time_stamp("1981-05-30 17:05:06")返回1981年5月30日17點5分6秒0毫秒的時標，用戶也可以調用get_time_stamp(1981, 5, 30, 17, 5, 6, 0)獲得同樣的結果。</p>
</td>
</tr>
<tr>
<td><center>get_variable_results</center></td>
<td><p>get_variable_results(2) :</p>
<p>get_variable_results(x, y)返回solve程式塊返回值x中該solve程式塊第y+1個待解變數的所有值。註意本函數程式返回一個一維陣列，陣列中的每一個元素是該待解變數的一個根。</p>
</td>
</tr>
<tr>
<td><center>get_working_dir</center></td>
<td><p>get_working_dir(0) :</p>
<p>get_working_dir()（別名pwd()）返回基於字串的當前路徑。</p>
</td>
</tr>
<tr>
<td><center>get_year</center></td>
<td><p>get_year(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分別返回時標timestamp所對應的年，月，本年中的第幾天，本月中的第幾天，本星期中的第幾天（禮拜天是第0天，禮拜一是第一天，...），小時，分鐘，秒鐘和毫秒。時標是時標所表示的時刻和1970年1月1日午夜（UTC）的毫秒數時間差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是禮拜天。</p>
</td>
</tr>
<tr>
<td><center>iff</center></td>
<td><p>iff(3...) :</p>
<p>函數程式iff(condition1, true_result1, condition2, true_result2, ..., false_result)的參數condition1，condition2，...為代表條件的布爾值，iff函數程式的返回值由條件值決定。比如，iff(true, 3, 2)返回3，iff(3 &lt; 2, 3, 2)返回2（這是因為3 &lt; 2是false），iff(3 &lt; 2, 3, 5 &gt; 4, 5, 6 == 9, 6, 9)返回5，以及iff(3 &lt; 2, 3, 5 &lt; 4, 5, 6 == 9, 6, 9)返回9。</p>
</td>
</tr>
<tr>
<td><center>image</center></td>
<td><p>image(1) :</p>
<p>image(x)返回復數x的虛部的實數值。</p>
<p>image(2) :</p>
<p>image(x, mode)返回復數x的虛部。如果參數mode是true，則返回虛數值，否則返回實數值。比如image(3+2i, true) = 2i而image(3+2i, false) = 2。</p>
</td>
</tr>
<tr>
<td><center>includes_inf</center></td>
<td><p>includes_inf(1) :</p>
<p>includes_inf(x)用於判斷參數x是否包含正負無窮。這裏，包含指的是，如果x是個陣列，那麽它的某一個元素包含或者本身就是目標值，如果x是一個復數，那麽它的實部或者虛部是目標值，如果x是一個實數，那麽它就是目標值。如果是，返回true，否則，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_nan</center></td>
<td><p>includes_nan(1) :</p>
<p>includes_nan(x)用於判斷參數x是否包含Nan。這裏，包含指的是，如果x是個陣列，那麽它的某一個元素包含或者本身就是目標值，如果x是一個復數，那麽它的實部或者虛部是目標值，如果x是一個實數，那麽它就是目標值。如果是，返回true，否則，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_nan_or_inf</center></td>
<td><p>includes_nan_or_inf(1) :</p>
<p>includes_nan_or_inf(x)用於判斷參數x是否包含Nan或者正負無窮。這裏，包含指的是，如果x是個陣列，那麽它的某一個元素包含或者本身就是目標值，如果x是一個復數，那麽它的實部或者虛部是目標值，如果x是一個實數，那麽它就是目標值。如果是，返回true，否則，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_nan_or_inf_or_null</center></td>
<td><p>includes_nan_or_inf_or_null(1) :</p>
<p>includes_nan_or_inf_or_null(x)用於判斷參數x是否包含Nan或者正負無窮或者null。這裏，包含指的是，如果x是個陣列，那麽它的某一個元素包含或者本身就是目標值，如果x是一個復數，那麽它的實部或者虛部是目標值，如果x是一個實數，那麽它就是目標值。如果是，返回true，否則，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_null</center></td>
<td><p>includes_null(1) :</p>
<p>includes_null(x)用於判斷參數x是否包含null。這裏，包含指的是，如果x是個陣列，那麽它的某一個元素包含或者本身就是目標值，如果x是一個復數，那麽它的實部或者虛部是目標值，如果x是一個實數，那麽它就是目標值。如果是，返回true，否則，返回false。</p>
</td>
</tr>
<tr>
<td><center>input</center></td>
<td><p>input(2) :</p>
<p>input(prompt,input_type)程式打印出提示符prompt並等待用戶輸入。第二個參數input_type可以省略。如果第二個參數不省略並且其為字串"s"或"S"，用戶的輸入將會被看成一個字串，並且這個程式返回輸入的字串。否則，輸入被當作一個表達式來處理，而這個程式返回表達式的值。如果輸入的不是一個合法的表達式，本程式將再次打印出提示符，等待用戶重新輸入。用戶如果要結束一次輸入需要按回車鍵。如果一次輸入多行，只有第一行會被處理。本程式的一個例子為，用戶運行input("$", "S")，然後在提示符後輸入4 + 3，按回車鍵，本程式將會返回字串"4 + 3"。而如果用戶運行input("%")，然後在提示符後輸入4 + 3，按回車鍵，本程式將會返回7。</p>
</td>
</tr>
<tr>
<td><center>integrate</center></td>
<td><p>integrate(2) :</p>
<p>integrate(x,y)返回基於變數y的表達式x的不定積分，表達式x和變數y均為字串。註意如果表達式x不存在不定積分，或者x過於復雜無法解出其不定積分，本函數程式將會拋出異常。</p>
<p>integrate(4) :</p>
<p>integrate(x,y,z,w)返回表達式x在變數y從z到w的積分值。表達式x和變數y均為字串，z和w可以為實數，復數或字串。註意本函數程式采用的積分算法是自適應Gauss-Kronrod積分法。</p>
<p>integrate(5) :</p>
<p>integrate(x,y,z,w,v)返回表達式x相對於變數y從w到z的積分。計算時每一步步長為(w-z)/v。表達式x和變數y均為字串，z和w可以為實數，復數或字串，v必須為正整數。註意如果v是0，則相當於執行integrate(x,y,z,w)。</p>
</td>
</tr>
<tr>
<td><center>invert</center></td>
<td><p>invert(1) :</p>
<p>invert(x)返回方塊2維矩陣x的逆矩陣，註意x中的元素可以為復數。</p>
</td>
</tr>
<tr>
<td><center>is_directory</center></td>
<td><p>is_directory(1) :</p>
<p>is_directory(path)用於判斷位於字串path的檔案（或者目錄）是否是一個目錄。如果該檔案或目錄存在並且是一個目錄返回true，否則返回false。例子包括is_directory("E:\\") (Windows)和is_directory("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_eye</center></td>
<td><p>is_eye(2) :</p>
<p>is_eye(x,y)用於確定數組（或數）x是否是單位陣I（或數字1），如果是，返回true，否則返回false。參數y是布爾量，可以省略，缺省值為false。如果y是true，將所有的null值視為0，否則，null值不被當作0。</p>
</td>
</tr>
<tr>
<td><center>is_file_executable</center></td>
<td><p>is_file_executable(1) :</p>
<p>is_file_executable(path)用于判断位于字串path的档案（或者目录）是否可执行。如果该档案或目录存在并且可执行返回true，否则返回false。例子包括is_file_executable("E:\\") (Windows)和is_file_executable("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_file_existing</center></td>
<td><p>is_file_existing(1) :</p>
<p>is_file_existing(path)用於判斷位於字串path的文件（或者目錄）是否存在。如果存在返回true，否則返回false。例子包括is_file_existing("E:\\") (Windows)和is_file_existing("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_file_hidden</center></td>
<td><p>is_file_hidden(1) :</p>
<p>is_file_hidden(path)用于判断位于字串path的档案（或者目录）是否隱藏。如果该档案或目录存在并且隱藏返回true，否则返回false。例子包括is_file_hidden("E:\\") (Windows)和is_file_hidden("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_file_normal</center></td>
<td><p>is_file_normal(1) :</p>
<p>is_file_normal(path)用于判断位于字串path的档案（或者目录）是否是一個常規檔案而不是目錄。如果该档案或目录存在并且是一個常規檔案而不是目錄返回true，否则返回false。例子包括is_file_normal("E:\\") (Windows)和is_file_normal("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_file_readable</center></td>
<td><p>is_file_readable(1) :</p>
<p>is_file_readable(path)用于判断位于字串path的档案（或者目录）是否可讀。如果该档案或目录存在并且可讀返回true，否则返回false。例子包括is_file_readable("E:\\") (Windows)和is_file_readable("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_file_writable</center></td>
<td><p>is_file_writable(1) :</p>
<p>is_file_writable(path)用于判断位于字串path的档案（或者目录）是否可寫。如果该档案或目录存在并且可寫返回true，否则返回false。例子包括is_file_writable("E:\\") (Windows)和is_file_writable("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_inf</center></td>
<td><p>is_inf(1) :</p>
<p>is_inf(x)用於判斷參數x是否為正負無窮。如果是，返回true，否則，返回false。</p>
</td>
</tr>
<tr>
<td><center>is_nan_or_inf</center></td>
<td><p>is_nan_or_inf(1) :</p>
<p>is_nan_or_inf(x)用於判斷參數x是否為Nan或者正負無窮。如果是，返回true，否則，返回false。</p>
</td>
</tr>
<tr>
<td><center>is_nan_or_inf_or_null</center></td>
<td><p>is_nan_or_inf_or_null(1) :</p>
<p>is_nan_or_inf_or_null(x)用於判斷參數x是否為Nan或者正負無窮或者null。如果是，返回true，否則，返回false。</p>
</td>
</tr>
<tr>
<td><center>is_path_absolute</center></td>
<td><p>is_path_absolute(1) :</p>
<p>is_path_absolute(path)用于判断位于字串path是否是一個絕對路徑（也就是不是相對於當前目錄的路徑）。如果是返回true，否则返回false。例子包括is_path_absolute("E:\\temp") (Windows)和is_path_absolute("Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_path_parent</center></td>
<td><p>is_path_parent(2) :</p>
<p>is_path_parent(path1, path2)用於判斷位於字串path1是否是字符串path2的上級目錄。如果是返回true，否則返回false。例子包括is_path_parent("E:\\temp", "E:\\temp\\..\\temp\\test") (Windows)和is_path_parent(".", "Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_path_same</center></td>
<td><p>is_path_same(2) :</p>
<p>is_path_same(path1, path2)用於判斷位於字串path1是否和字串path2指向同一條路徑。如果是返回true，否則返回false。例子包括is_path_same("E:\\temp", "E:\\temp\\..\\temp\\") (Windows)和is_path_parent("/home/tony/Documents", "Documents/") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_symbol_link</center></td>
<td><p>is_symbol_link(1) :</p>
<p>is_symbol_link(path)用于判断位于字串path的档案（或者目录）是否是一個符號鏈接。如果该档案或目录存在并且是一個符號鏈接返回true，否则返回false。例子包括is_symbol_link("E:\\") (Windows)和is_symbol_link("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_zeros</center></td>
<td><p>is_zeros(2) :</p>
<p>is_zeros(x,y)用於確定數組（或數）x是否是零矩陣（或數字0），如果是，返回true，否則返回false。參數y是布爾量，可以省略，缺省值為false。如果y是true，將所有的null值視為0，否則，null值不被當作0。</p>
</td>
</tr>
<tr>
<td><center>left_recip</center></td>
<td><p>left_recip(1) :</p>
<p>left_recip(x)計算x的左除倒數，註意當前僅支持數值或二維陣列。</p>
</td>
</tr>
<tr>
<td><center>lim</center></td>
<td><p>lim(3) :</p>
<p>lim(expr, var, dest_value)用於計算表達式expr在變數var趨近於dest_value時的值。expr和var必須為字串，dest_value為表達式或者數值，可以基於字串，也可以不基於字串。比如，lim("1/x", "x", 0)或者lim("(x+2)/(x+3)","x","3+0")。註意這個函數程式還在開發中。</p>
</td>
</tr>
<tr>
<td><center>list_files</center></td>
<td><p>list_files(1) :</p>
<p>list_files(path)返回位於字串path路徑的目錄中的所有子檔案或者子目錄的名字，或者如果path路徑對應的是一個檔案，它返回該檔案的名字。如果不存在一個檔案或者目錄對應於path路徑，它返回NULL。註意參數path是可以省略的。它的缺省值是當前目錄。例子包括list_files("c:\\temp\\try1") (Windows)和list_files("../testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>log</center></td>
<td><p>log(1) :</p>
<p>log(x)返回x的自然對數，註意x可以為復數。</p>
</td>
</tr>
<tr>
<td><center>ls</center></td>
<td><p>ls(1) :</p>
<p>print_file_list(path) (别名ls(path)或者dir(path))函數程式和Windows平臺上的dir命令以及Linux平臺上的ls命令類似。它打印出位於字串path路徑的档案或者目錄中的所有子档案和子目錄的信息。它返回打印的條目的個數。如果不存在一個檔案或者目錄對應於path路徑，它返回-1。註意參數path是可以省略的。它的缺省值是當前目錄。例子包括dir("c:\\temp\\try1") (Windows)和ls("../testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>mod</center></td>
<td><p>mod(2) :</p>
<p>mod(x,y)返回x除以正整數y的餘數，如果x或者y不是整數，將被首先轉換為整數。</p>
</td>
</tr>
<tr>
<td><center>move_file</center></td>
<td><p>move_file(3) :</p>
<p>move_file(source, destination, replace_exist)函數程式移動位於字串source路徑的檔案或檔案目錄到位於字串destination路徑的檔案或位於destination路徑的檔案目錄內（而不是位於destination路徑的檔案目錄本身）。如果第三個參數，replace_exist，是true，那麼如果目標檔案已經存在，它將會被源檔案（或者源檔案目錄中的對應檔案）替換。註意第三個參數可以省略，它的缺省值為false。例子包括move_file("c:\\temp\\try1", "D:\\", true) (Windows)和copy_file("/mnt/sdcard/testfile.txt", "./testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>now</center></td>
<td><p>now(0) :</p>
<p>now()返回當前時刻和1970年1月1日午夜（UTC）的毫秒數時間差。</p>
</td>
</tr>
<tr>
<td><center>ones</center></td>
<td><p>ones(1...) :</p>
<p>ones函數返回一個所有元素都是1的矩陣，本函數的參數用於決定矩陣的尺寸，要麽為一批正整數，要麽為一個正整數數列。註意表達式ones([])返回常數1。</p>
</td>
</tr>
<tr>
<td><center>or</center></td>
<td><p>or(1...) :</p>
<p>or(x...)接受不少於1個的任意個數的參數，返回這些參數的邏輯或值。如果某一個參數不是布爾類型，將會被自動轉換為布爾類型。</p>
</td>
</tr>
<tr>
<td><center>pause</center></td>
<td><p>pause(1) :</p>
<p>pause(message)將暫停當前運行的程式，等待用戶輸入一個回車，然後繼續。字串參數message可以省略。如果不省略，message將作為提示被打印在熒幕上。</p>
</td>
</tr>
<tr>
<td><center>plot_multi_xy</center></td>
<td><p>plot_multi_xy(26) :</p>
<p>plot_multi_xy(包含2到26個參數)用於繪制2維或極坐標圖像，每個圖像最多包括8條曲線。參數1為圖像名字，參數2為圖像設置，該參數是一個字串，比如"chart_type:multiXY;chart_title:1 chart;x_title:x;x_min:-6.2796950076838645;x_max:6.918480857169536;x_labels:10;y_title:y;y_min:-4.487378580559947;y_max:4.1268715788884345;y_labels:10;background_color:black;show_grid:true"。註意chart_type的值是multiXY（用於繪制二維圖像）或者multiRangle（用於繪制極坐標圖像），x_labels和y_lables分別代表x和y軸上有多少刻度標記（對於極坐標圖像是R軸有多少刻度標記，幅角的刻度標記不可設）。從參數3到參數26，每3個參數定義一條曲線，在這3個參數中，第一個參數為曲線設置，第二個參數是包含所有x數值（或者R數值）的向量，第三個參數是包括所有y值（或者幅角值）的向量。曲線設置參數為一個字串，比如"curve_label:cv2;point_color:blue;point_style:point;point_size:1;line_color:blue;line_style:solid;line_size:1"。另外註意x和y的每一個數值都必須為實數，x和y的數值個數必須一致。本函數程式不返回數值。本函數程式的一個例子是plot_multi_xy("chart2", "chart_type:multiXY;chart_title:1 chart;x_title:x;x_min:-6;x_max:6;x_labels:6;y_title:y;y_min:-4;y_max:4;y_labels:5;background_color:black;show_grid:true", "curve_label:cv2;point_color:blue;point_style:circle;point_size:3;line_color:blue;line_style:solid;line_size:1", [-5, -3, -1, 0, 1, 2, 3, 4, 5], [-3.778, -2.9793, -2.0323, -1.1132, 0.2323, 1.2348, 3.9865, 2.3450, 0.4356]) 。</p>
</td>
</tr>
<tr>
<td><center>plot_multi_xyz</center></td>
<td><p>plot_multi_xyz(34) :</p>
<p>plot_multi_xyz(包含2到34個參數)用於繪制3維圖像，每個圖像最多包括8條曲面。參數1為圖像名字，參數2為圖像設置，圖像設置參數是一個字串，比如"chart_type:multiXYZ;chart_title:This is a graph;x_title:x axis;x_min:-24.43739154366772;x_max:24.712391543667717;x_labels:10;y_title:Y axis;y_min:-251.3514430737091;y_max:268.95144307370913;y_labels:10;z_title:Z axis;z_min:-1.6873277335234405;z_max:1.7896774628184482;z_labels:10"。需要註意的是chart_type的值必須是multiXYZ，x_labels，y_labels和z_lables分別代表x，y和z軸上有多少刻度標記。從參數3到參數34，每4個參數定義一條曲線，在這4個參數中，第一個參數為曲線設置，第二個參數是包含所有x數值的陣列，第三個參數是包括所有y值的陣列，第四個參數是包括所有z值的陣列。曲線設置參數為一個字串，比如"curve_label:cv2;is_grid:true;min_color:blue;min_color_1:cyan;min_color_value:-2.0;max_color:white;max_color_1:yellow;max_color_value:2.0"。另外註意x，y和z的每一個數值都必須為實數，x，y和z的陣列的尺寸必須一致。本函數程式不返回數值。本函數程式的一個例子為：plot_multi_xyz("chartII", "chart_type:multiXYZ;chart_title:This is a graph;x_title:x;x_min:-5;x_max:5;x_labels:6;y_title:Y;y_min:-6;y_max:6;y_labels:3;z_title:Z;z_min:-3;z_max:1;z_labels:4", "curve_label:cv1;min_color:blue;min_color_1:green;max_color:yellow;max_color_1:red", [[-4, -2, 0, 2, 4],[-4, -2, 0, 2, 4],[-4, -2, 0, 2, 4]], [[-5, -5, -5, -5, -5], [0, 0, 0, 0, 0], [-5, -5, -5, -5, -5]], [[-2.71, -2.65, -2.08, -1.82, -1.77], [-2.29, -2.36, -1.88, -1.45, -1.01], [-1.74, -1.49, -0.83, -0.17, 0.44]]) 。</p>
</td>
</tr>
<tr>
<td><center>pow</center></td>
<td><p>pow(2) :</p>
<p>pow(x,y)返回x的y次方，註意x和y可以為實數，可以為虛數。如果結果有多個值，返回第一個值。</p>
<p>pow(3) :</p>
<p>pow(x,y,z)返回包含x的y次方的前z個值組成的一個向量，如果x的y次方只有少於z個值，返回所有值。注意y必須為實數，x可以為實數，可以為虛數，z必須為正整數。</p>
</td>
</tr>
<tr>
<td><center>print</center></td>
<td><p>print(1) :</p>
<p>print(x)向輸出端列印任意資料類型x的值。</p>
</td>
</tr>
<tr>
<td><center>print_file_list</center></td>
<td><p>print_file_list(1) :</p>
<p>print_file_list(path) (别名ls(path)或者dir(path))函數程式和Windows平臺上的dir命令以及Linux平臺上的ls命令類似。它打印出位於字串path路徑的档案或者目錄中的所有子档案和子目錄的信息。它返回打印的條目的個數。如果不存在一個檔案或者目錄對應於path路徑，它返回-1。註意參數path是可以省略的。它的缺省值是當前目錄。例子包括dir("c:\\temp\\try1") (Windows)和ls("../testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>printf</center></td>
<td><p>printf(1...) :</p>
<p>printf(format_string, ...)，sprintf(format_string, ...)和fprintf(fd, format_string, ...)和C/C++中的对应函数程式工作方式相似。这些函数程式通过format_string和其后的数值参数构造出一个新的字串，printf将字串打印到标准输出，sprintf将字串作为返回值返回，fprintf则将字串输出到档案号为fd的文本档案。字串format_string支持输入整数（%d、%i、%x等），浮点数（%e、%f等），字符和字串（%c和%s）等等。用户可以在C语言的帮助手册中找到format_string的构造方法。例如，printf("Hello world!%f", 3.14)将会打印输出"Hello world!3.140000"，而sprintf("%c%d", "A", 9)则返回"A9"（注意MFP不支持单一字符数据类型，所以单一的字符将会存储为一个只包括一个字符的字串）。</p>
</td>
</tr>
<tr>
<td><center>product_over</center></td>
<td><p>product_over(3) :</p>
<p>函數程式product_over(x, y, z)計算基於字串的表達式x中的變數取值從整數y逐步變化到整數z的值的乘積。y和z必須是字串的形式，其中，y必須寫成一個賦值表達式，比如"a=10"，這裏，a是變數名。本函數程式的一個例子為product_over("x+1", "x=1", "10")。</p>
</td>
</tr>
<tr>
<td><center>pwd</center></td>
<td><p>pwd(0) :</p>
<p>get_working_dir()（別名pwd()）返回基於字串的當前路徑。</p>
</td>
</tr>
<tr>
<td><center>rand</center></td>
<td><p>rand(0) :</p>
<p>rand()函數返回一個大於等於0小於1的隨機浮點數。</p>
</td>
</tr>
<tr>
<td><center>rank</center></td>
<td><p>rank(1) :</p>
<p>rank(matrix)返回矩陣的秩。比如，rank([[1,2],[2,4]])將返回1。</p>
</td>
</tr>
<tr>
<td><center>real</center></td>
<td><p>real(1) :</p>
<p>real(x)返回覆數x的實部。</p>
</td>
</tr>
<tr>
<td><center>recip</center></td>
<td><p>recip(1) :</p>
<p>recip(x)計算x的倒數，註意當前僅支持數值或二維陣列。</p>
</td>
</tr>
<tr>
<td><center>round</center></td>
<td><p>round(1) :</p>
<p>round(x)，x是浮點數，返回x的四捨五入值。</p>
<p>round(2) :</p>
<p>round(x,y)，x是浮點數，y為非負整數，返回小數點後有y位數字的x的四舍五入值。</p>
</td>
</tr>
<tr>
<td><center>scanf</center></td>
<td><p>scanf(1) :</p>
<p>scanf(format_string)，sscanf(input_from, format_string)和fscanf(fd, format_string)和C/C++中的對應函數程式工作方式相似。scanf讀取用戶的一行輸入，sscanf讀取字串input_from，fscanf從檔案（檔案號fd）中讀取檔案內容。字串format_string支持輸入整數（%d、%i、%x等），浮點數（%e、%f等），字符和字串（%c和%s）等等。用戶可以在C語言的幫助文檔中找到format_string的構造方法。但是，和C語言有所不同，MFP中的這些函數程式不需要輸入用於存儲讀取數值的參數。所有的讀取的數值將會保存在一個數組中作為返回值返回。比如，sscanf("3Hello world!", "%d%c%c%s")將會返回[3, "H", "e", "llo"]（註意MFP不支持單一字符數據類型，所以單一的字符將會存儲為一個只包括一個字符的字串）。</p>
</td>
</tr>
<tr>
<td><center>set_array_elem</center></td>
<td><p>set_array_elem(3) :</p>
<p>set_array_elem(x,y,z)將x[y]賦值為z，並且返回新的x。註意x不是必須為矩陣，y必須為正整數向量。y的值可以超出x的尺寸和維度。比如，如果x=3，y=[1,2]，z=2+3i，那麽set_array_elem(x,y,z)等於[3, [0, 0, 2+3i]]。</p>
</td>
</tr>
<tr>
<td><center>set_file_last_modified_time</center></td>
<td><p>set_file_last_modified_time(2) :</p>
<p>set_file_last_modified_time(path, time)设置基于字串路径的path的档案或目录的上一次更改时间为time。该时间等于从1970年1月1日午夜开始到上一次更改时刻所经历的毫秒数。如果path不存在或者没有访问权限，返回false，否则返回true。例子包括("C:\\Temp\\Hello\\", 99999999) (Windows)和set_file_last_modified_time("./hello.txt", 1111111111) (Android)。</p>
</td>
</tr>
<tr>
<td><center>sin</center></td>
<td><p>sin(1) :</p>
<p>sin(x)返回x的正弦值，註意x可以為復數。</p>
</td>
</tr>
<tr>
<td><center>size</center></td>
<td><p>size(1) :</p>
<p>size(x)返回矩陣x的尺寸向量。註意如果x不是一個矩陣，則總是返回[]。</p>
<p>size(2) :</p>
<p>size(x,y)返回矩陣x前y維的尺寸向量，如果x少於y維，返回完整的尺寸向量，注意y必須為正整數。此外如果x不是一個矩陣，則總是返回[]。</p>
</td>
</tr>
<tr>
<td><center>sleep</center></td>
<td><p>sleep(1) :</p>
<p>sleep(x)休眠x毫秒（x必須為正實數），此函數不返回任何值。</p>
</td>
</tr>
<tr>
<td><center>split</center></td>
<td><p>split(2) :</p>
<p>string_regex)j將字串string_input按照正則表達式string_regex分割為若幹個子字串並返回包含所有子字串的數組。用戶可以閱讀JAVA語言的Pattern類和String.split函數程式的幫助檔案獲得更多關於正則表達式使用方法的資訊。例子包括split("boo:and:foo", ":")返回["boo", "and", "foo"]以及split("boo:and:foo", "o")返回["b", "", ":and:f"]。</p>
</td>
</tr>
<tr>
<td><center>sprintf</center></td>
<td><p>sprintf(1...) :</p>
<p>printf(format_string, ...)，sprintf(format_string, ...)和fprintf(fd, format_string, ...)和C/C++中的对应函数程式工作方式相似。这些函数程式通过format_string和其后的数值参数构造出一个新的字串，printf将字串打印到标准输出，sprintf将字串作为返回值返回，fprintf则将字串输出到档案号为fd的文本档案。字串format_string支持输入整数（%d、%i、%x等），浮点数（%e、%f等），字符和字串（%c和%s）等等。用户可以在C语言的帮助手册中找到format_string的构造方法。例如，printf("Hello world!%f", 3.14)将会打印输出"Hello world!3.140000"，而sprintf("%c%d", "A", 9)则返回"A9"（注意MFP不支持单一字符数据类型，所以单一的字符将会存储为一个只包括一个字符的字串）。</p>
</td>
</tr>
<tr>
<td><center>sscanf</center></td>
<td><p>sscanf(2) :</p>
<p>scanf(format_string)，sscanf(input_from, format_string)和fscanf(fd, format_string)和C/C++中的對應函數程式工作方式相似。scanf讀取用戶的一行輸入，sscanf讀取字串input_from，fscanf從檔案（檔案號fd）中讀取檔案內容。字串format_string支持輸入整數（%d、%i、%x等），浮點數（%e、%f等），字符和字串（%c和%s）等等。用戶可以在C語言的幫助文檔中找到format_string的構造方法。但是，和C語言有所不同，MFP中的這些函數程式不需要輸入用於存儲讀取數值的參數。所有的讀取的數值將會保存在一個數組中作為返回值返回。比如，sscanf("3Hello world!", "%d%c%c%s")將會返回[3, "H", "e", "llo"]（註意MFP不支持單一字符數據類型，所以單一的字符將會存儲為一個只包括一個字符的字串）。</p>
</td>
</tr>
<tr>
<td><center>strcat</center></td>
<td><p>strcat(2...) :</p>
<p>strcat(string1, string2...)將字串參數順次連接在一起，返回新的連接好的字串。本函數程式需要至少兩個參數。</p>
</td>
</tr>
<tr>
<td><center>strcmp</center></td>
<td><p>strcmp(6) :</p>
<p>strcmp(src, dest, src_start, src_end, dest_start, dest_end)比較源字串src（從src_start到src_end）和目標字串dest（從dest_start到dest_end）。如果src和dest相等返回0，如果src大於dest返回大於0的值，如果src小於dest返回小於0的值。注意字串索引從0開始，src_end和dest_end的索引位置為最後一個被選中字元的索引位置加一。另外，最後四個參數可以省略，如果被省略，src_start和dest_start的預設值為0，src_end和dest_end的預設值為對應字串的長度。</p>
</td>
</tr>
<tr>
<td><center>strcpy</center></td>
<td><p>strcpy(6) :</p>
<p>strcpy(src, dest, src_start, src_end, dest_start, dest_end)返回將源字串src從src_start到src_end拷貝到目標字串dest從dest_start到dest_end的新字串值。注意字串索引從0開始，src_end和dest_end的索引位置為最後一個被選中字元的索引位置加一。另外，最後四個參數可以省略，如果被省略，src_start和dest_start的預設值為0，src_end和dest_end的預設值為對應字串的長度。</p>
</td>
</tr>
<tr>
<td><center>stricmp</center></td>
<td><p>stricmp(6) :</p>
<p>stricmp(src, dest, src_start, src_end, dest_start, dest_end)在忽略字母大小寫的前提下比較源字符串src（從src_start到src_end）和目標字符串dest（從dest_start到dest_end）。如果src和dest相等返回0，如果src大於dest返回大於0的值，如果src小於dest返回小於0的值。註意字符串索引從0開始，src_end和dest_end的索引位置為最後一個被選中字符的索引位置加一。另外，最後四個參數可以省略，如果被省略，src_start和dest_start的缺省值為0，src_end和dest_end的缺省值為對應字符串的長度。</p>
</td>
</tr>
<tr>
<td><center>strlen</center></td>
<td><p>strlen(1) :</p>
<p>strlen(x)返回字串x的長度。</p>
</td>
</tr>
<tr>
<td><center>strsub</center></td>
<td><p>strsub(2) :</p>
<p>strsub(str, start)返回字串str的子字串。該子字串從字元start開始到str的最後一個字元。注意字串的第一個字元是0號字元。</p>
<p>strsub(3) :</p>
<p>strsub(str, start, end)返回字串str的子字串。該子字串從字元start開始到字元end-1。注意字串的第一個字元是0號字元。</p>
</td>
</tr>
<tr>
<td><center>sum_over</center></td>
<td><p>sum_over(3) :</p>
<p>函數程式sum_over(x, y, z)計算基於字串的表達式x中的變數取值從整數y逐步變化到整數z的值的總合。y和z必須是字串的形式，其中，y必須寫成一個賦值表達式，比如"a=10"，這裏，a是變數名。本函數程式的一個例子為sum_over("x+1", "x=1", "10")。</p>
</td>
</tr>
<tr>
<td><center>system</center></td>
<td><p>system(1) :</p>
<p>system(str)運行一個系統指令並且返回該系統指令的返回值。註意系統指令必須是一個可執行的檔案以及它的命令參數。由於這個原因，在Windows平臺上，諸如system("dir")無法正確執行是因為dir並非是一個單獨的可執行檔案，而是cmd.exe的一個內部功能。要執行dir指令，用戶需要運行system("cmd /c dir")。還要註意，在現階段，這個函數程式只能將系統指令的輸出打印出來，還無法接受在運行中用戶對於該系統指令的輸入。此外，如果該系統指令不存在，則會拋出異常。</p>
</td>
</tr>
<tr>
<td><center>tan</center></td>
<td><p>tan(1) :</p>
<p>tan(x)返回x的正切值，註意x可以為復數。</p>
</td>
</tr>
<tr>
<td><center>to_lowercase_string</center></td>
<td><p>to_lowercase_string(1) :</p>
<p>to_lowercase_string(x)返回數據x的打印值（所有的字母均為小寫）。</p>
</td>
</tr>
<tr>
<td><center>to_string</center></td>
<td><p>to_string(1) :</p>
<p>to_string(x)返回數據x的打印值。</p>
</td>
</tr>
<tr>
<td><center>to_uppercase_string</center></td>
<td><p>to_uppercase_string(1) :</p>
<p>to_uppercase_string(x)返回數據x的打印值（所有的字母均為大寫）。</p>
</td>
</tr>
<tr>
<td><center>tostring</center></td>
<td><p>tostring(1) :</p>
<p>tostring(x) 返回數據x的打印值。</p>
</td>
</tr>
<tr>
<td><center>trim</center></td>
<td><p>trim(1) :</p>
<p>trim(string)，trim_left(string)和trim_right(string)從字串的兩邊或者一邊刪除任何一個ASCI值小於等於空白字符（' '）的字符。具體說來，trim從左右兩邊刪除任何一個ASCI值小於等於空白字符（' '）的字符，直到左邊和右邊都遇到了一個ASCI值大於空白字符（' '）的字符；trim_left從左邊刪除任何一個ASCI值小於等於空白字符（' '）的字符，直到遇到了一個ASCI值大於空白字符（' '）的字符；trim_right從右邊刪除任何一個ASCI值小於等於空白字符（' '）的字符，直到遇到了一個ASCI值大於空白字符（' '）的字符。例子包括trim(" \n hello world ") （返回"hello world"）, trim_left(" \n hello world "）, （返回"hello world "）以及trim_right(" \n hello world ") （返回" hello world")。</p>
</td>
</tr>
<tr>
<td><center>trim_left</center></td>
<td><p>trim_left(1) :</p>
<p>trim(string)，trim_left(string)和trim_right(string)從字串的兩邊或者一邊刪除任何一個ASCI值小於等於空白字符（' '）的字符。具體說來，trim從左右兩邊刪除任何一個ASCI值小於等於空白字符（' '）的字符，直到左邊和右邊都遇到了一個ASCI值大於空白字符（' '）的字符；trim_left從左邊刪除任何一個ASCI值小於等於空白字符（' '）的字符，直到遇到了一個ASCI值大於空白字符（' '）的字符；trim_right從右邊刪除任何一個ASCI值小於等於空白字符（' '）的字符，直到遇到了一個ASCI值大於空白字符（' '）的字符。例子包括trim(" \n hello world ") （返回"hello world"）, trim_left(" \n hello world "）, （返回"hello world "）以及trim_right(" \n hello world ") （返回" hello world")。</p>
</td>
</tr>
<tr>
<td><center>trim_right</center></td>
<td><p>trim_right(1) :</p>
<p>trim(string)，trim_left(string)和trim_right(string)從字串的兩邊或者一邊刪除任何一個ASCI值小於等於空白字符（' '）的字符。具體說來，trim從左右兩邊刪除任何一個ASCI值小於等於空白字符（' '）的字符，直到左邊和右邊都遇到了一個ASCI值大於空白字符（' '）的字符；trim_left從左邊刪除任何一個ASCI值小於等於空白字符（' '）的字符，直到遇到了一個ASCI值大於空白字符（' '）的字符；trim_right從右邊刪除任何一個ASCI值小於等於空白字符（' '）的字符，直到遇到了一個ASCI值大於空白字符（' '）的字符。例子包括trim(" \n hello world ") （返回"hello world"）, trim_left(" \n hello world "）, （返回"hello world "）以及trim_right(" \n hello world ") （返回" hello world")。</p>
</td>
</tr>
<tr>
<td><center>zeros</center></td>
<td><p>zeros(1...) :</p>
<p>zeros函數返回一個所有元素都是0的矩陣，本函數的參數用於決定矩陣的尺寸，要麽為一批正整數，要麽為一個正整數數列。註意表達式zeros([])返回常數值0。</p>
</td>
</tr>
</table>
</body>
</html>
